<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='utf-8'>
    <style>
        .node {
            cursor: pointer;
        }

        .node text {
            font: 12px helvetica;
        }

        .link {
            fill: #eee;
            opacity: 0.8;
        }
    </style>
</head>

<body>
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script>

        var margin = { top: 50, right: 50, bottom: 150, left: 50 };

        // collect all inputs
        var tree_depth = 5;
        var rules = {"0": [], "1": ["Sex: 0"], "3": ["Sex: 0", "Pclass <= 2"], "25": ["Sex: 0", "Age <= 2.5", "Pclass <= 2"], "27": ["Sex: 0", "Age <= 2.5", "Pclass <= 2", "Fare <= 4.162"], "28": ["Sex: 0", "Age <= 2.5", "Pclass <= 2", "Fare > 4.162"], "26": ["Sex: 0", "Age > 2.5", "Pclass <= 2"], "39": ["Sex: 0", "Pclass <= 2", "2.5 < Age <= 24.5"], "40": ["Sex: 0", "Age > 24.5", "Pclass <= 2"], "41": ["Sex: 0", "Pclass <= 2", "24.5 < Age <= 26.0"], "42": ["Sex: 0", "Age > 26.0", "Pclass <= 2"], "4": ["Sex: 0", "Pclass > 2"], "7": ["Sex: 0", "Pclass > 2", "Fare <= 3.193"], "13": ["Sex: 0", "Pclass > 2", "Age <= 36.5", "Fare <= 3.193"], "17": ["Sex: 0", "Pclass > 2", "Age <= 36.5", "Fare <= 2.168"], "18": ["Sex: 0", "Pclass > 2", "Age <= 36.5", "2.168 < Fare <= 3.193"], "14": ["Sex: 0", "Pclass > 2", "Age > 36.5", "Fare <= 3.193"], "8": ["Sex: 0", "Pclass > 2", "Fare > 3.193"], "31": ["Sex: 0", "Pclass > 2", "Age <= 7.0", "Fare > 3.193"], "33": ["Sex: 0", "Pclass > 2", "Age <= 7.0", "3.193 < Fare <= 3.476"], "34": ["Sex: 0", "Pclass > 2", "Age <= 7.0", "Fare > 3.476"], "32": ["Sex: 0", "Age > 7.0", "Pclass > 2", "Fare > 3.193"], "2": ["Sex: 1"], "5": ["Sex: 1", "Age <= 6.5"], "9": ["Sex: 1", "Age <= 6.5", "SibSp <= 3"], "10": ["Sex: 1", "SibSp > 3", "Age <= 6.5"], "35": ["Sex: 1", "SibSp > 3", "Age <= 6.5", "Parch <= 1"], "36": ["Sex: 1", "SibSp > 3", "Parch > 1", "Age <= 6.5"], "37": ["Sex: 1", "Parch > 1", "Age <= 6.5", "3 < SibSp <= 4"], "38": ["Sex: 1", "SibSp > 4", "Parch > 1", "Age <= 6.5"], "6": ["Sex: 1", "Age > 6.5"], "11": ["Sex: 1", "Age > 6.5", "Pclass <= 1"], "15": ["Sex: 1", "Age > 6.5", "Pclass <= 1", "Fare <= 5.908"], "19": ["Sex: 1", "Age > 6.5", "Pclass <= 1", "Fare <= 3.301"], "20": ["Sex: 1", "Age > 6.5", "Pclass <= 1", "3.301 < Fare <= 5.908"], "16": ["Sex: 1", "Age > 6.5", "Pclass <= 1", "Fare > 5.908"], "12": ["Sex: 1", "Age > 6.5", "Pclass > 1"], "21": ["Sex: 1", "Age > 6.5", "Pclass > 1", "Fare <= 3.96"], "29": ["Sex: 1", "Pclass > 1", "Fare <= 3.96", "6.5 < Age <= 13.0"], "30": ["Sex: 1", "Age > 13.0", "Pclass > 1", "Fare <= 3.96"], "22": ["Sex: 1", "Age > 6.5", "Pclass > 1", "Fare > 3.96"], "23": ["Sex: 1", "Age > 6.5", "Pclass > 1", "3.96 < Fare <= 4.154"], "24": ["Sex: 1", "Age > 6.5", "Pclass > 1", "Fare > 4.154"]};
        var num_node = 43;
        var width = 4000, height = 4000;
        var max_samples = 668;
        var min_samples = 1;
        var target_colors = ['red', 'green'];
        var root = {"name": "HEAD", "parent": "null", "self": 0, "sample": 668, "impurity": 0.471, "value": [415, 253], "predict": "Not Survived", "color": "red", "pos": "null", "children": [{"name": "Sex: 0", "parent": 0, "self": 1, "sample": 229, "impurity": 0.383, "value": [59, 170], "predict": "Survived", "color": "green", "pos": "left", "children": [{"name": "Pclass <= 2", "parent": 1, "self": 3, "sample": 120, "impurity": 0.064, "value": [4, 116], "predict": "Survived", "color": "green", "pos": "left", "children": [{"name": "Age <= 2.5", "parent": 3, "self": 25, "sample": 2, "impurity": 0.5, "value": [1, 1], "predict": "Not Survived", "color": "red", "pos": "left", "children": [{"name": "Fare <= 4.162", "parent": 25, "self": 27, "sample": 1, "impurity": 0.0, "value": [0, 1], "predict": "Survived", "color": "green", "pos": "left"}, {"name": "Fare > 4.162", "parent": 25, "self": 28, "sample": 1, "impurity": 0.0, "value": [1, 0], "predict": "Not Survived", "color": "red", "pos": "right"}]}, {"name": "Age > 2.5", "parent": 3, "self": 26, "sample": 118, "impurity": 0.05, "value": [3, 115], "predict": "Survived", "color": "green", "pos": "right", "children": [{"name": "Age <= 24.5", "parent": 26, "self": 39, "sample": 38, "impurity": 0.0, "value": [0, 38], "predict": "Survived", "color": "green", "pos": "left"}, {"name": "Age > 24.5", "parent": 26, "self": 40, "sample": 80, "impurity": 0.072, "value": [3, 77], "predict": "Survived", "color": "green", "pos": "right", "children": [{"name": "Age <= 26.0", "parent": 40, "self": 41, "sample": 1, "impurity": 0.0, "value": [1, 0], "predict": "Not Survived", "color": "red", "pos": "left"}, {"name": "Age > 26.0", "parent": 40, "self": 42, "sample": 79, "impurity": 0.049, "value": [2, 77], "predict": "Survived", "color": "green", "pos": "right"}]}]}]}, {"name": "Pclass > 2", "parent": 1, "self": 4, "sample": 109, "impurity": 0.5, "value": [55, 54], "predict": "Not Survived", "color": "red", "pos": "right", "children": [{"name": "Fare <= 3.193", "parent": 4, "self": 7, "sample": 91, "impurity": 0.486, "value": [38, 53], "predict": "Survived", "color": "green", "pos": "left", "children": [{"name": "Age <= 36.5", "parent": 7, "self": 13, "sample": 87, "impurity": 0.476, "value": [34, 53], "predict": "Survived", "color": "green", "pos": "left", "children": [{"name": "Fare <= 2.168", "parent": 13, "self": 17, "sample": 13, "impurity": 0.26, "value": [2, 11], "predict": "Survived", "color": "green", "pos": "left"}, {"name": "Fare > 2.168", "parent": 13, "self": 18, "sample": 74, "impurity": 0.491, "value": [32, 42], "predict": "Survived", "color": "green", "pos": "right"}]}, {"name": "Age > 36.5", "parent": 7, "self": 14, "sample": 4, "impurity": 0.0, "value": [4, 0], "predict": "Not Survived", "color": "red", "pos": "right"}]}, {"name": "Fare > 3.193", "parent": 4, "self": 8, "sample": 18, "impurity": 0.105, "value": [17, 1], "predict": "Not Survived", "color": "red", "pos": "right", "children": [{"name": "Age <= 7.0", "parent": 8, "self": 31, "sample": 3, "impurity": 0.444, "value": [2, 1], "predict": "Not Survived", "color": "red", "pos": "left", "children": [{"name": "Fare <= 3.476", "parent": 31, "self": 33, "sample": 2, "impurity": 0.0, "value": [2, 0], "predict": "Not Survived", "color": "red", "pos": "left"}, {"name": "Fare > 3.476", "parent": 31, "self": 34, "sample": 1, "impurity": 0.0, "value": [0, 1], "predict": "Survived", "color": "green", "pos": "right"}]}, {"name": "Age > 7.0", "parent": 8, "self": 32, "sample": 15, "impurity": 0.0, "value": [15, 0], "predict": "Not Survived", "color": "red", "pos": "right"}]}]}]}, {"name": "Sex: 1", "parent": 0, "self": 2, "sample": 439, "impurity": 0.307, "value": [356, 83], "predict": "Not Survived", "color": "red", "pos": "right", "children": [{"name": "Age <= 6.5", "parent": 2, "self": 5, "sample": 21, "impurity": 0.408, "value": [6, 15], "predict": "Survived", "color": "green", "pos": "left", "children": [{"name": "SibSp <= 3", "parent": 5, "self": 9, "sample": 14, "impurity": 0.0, "value": [0, 14], "predict": "Survived", "color": "green", "pos": "left"}, {"name": "SibSp > 3", "parent": 5, "self": 10, "sample": 7, "impurity": 0.245, "value": [6, 1], "predict": "Not Survived", "color": "red", "pos": "right", "children": [{"name": "Parch <= 1", "parent": 10, "self": 35, "sample": 4, "impurity": 0.0, "value": [4, 0], "predict": "Not Survived", "color": "red", "pos": "left"}, {"name": "Parch > 1", "parent": 10, "self": 36, "sample": 3, "impurity": 0.444, "value": [2, 1], "predict": "Not Survived", "color": "red", "pos": "right", "children": [{"name": "SibSp <= 4", "parent": 36, "self": 37, "sample": 2, "impurity": 0.5, "value": [1, 1], "predict": "Not Survived", "color": "red", "pos": "left"}, {"name": "SibSp > 4", "parent": 36, "self": 38, "sample": 1, "impurity": 0.0, "value": [1, 0], "predict": "Not Survived", "color": "red", "pos": "right"}]}]}]}, {"name": "Age > 6.5", "parent": 2, "self": 6, "sample": 418, "impurity": 0.272, "value": [350, 68], "predict": "Not Survived", "color": "red", "pos": "right", "children": [{"name": "Pclass <= 1", "parent": 6, "self": 11, "sample": 84, "impurity": 0.444, "value": [56, 28], "predict": "Not Survived", "color": "red", "pos": "left", "children": [{"name": "Fare <= 5.908", "parent": 11, "self": 15, "sample": 82, "impurity": 0.433, "value": [56, 26], "predict": "Not Survived", "color": "red", "pos": "left", "children": [{"name": "Fare <= 3.301", "parent": 15, "self": 19, "sample": 7, "impurity": 0.0, "value": [7, 0], "predict": "Not Survived", "color": "red", "pos": "left"}, {"name": "Fare > 3.301", "parent": 15, "self": 20, "sample": 75, "impurity": 0.453, "value": [49, 26], "predict": "Not Survived", "color": "red", "pos": "right"}]}, {"name": "Fare > 5.908", "parent": 11, "self": 16, "sample": 2, "impurity": 0.0, "value": [0, 2], "predict": "Survived", "color": "green", "pos": "right"}]}, {"name": "Pclass > 1", "parent": 6, "self": 12, "sample": 334, "impurity": 0.211, "value": [294, 40], "predict": "Not Survived", "color": "red", "pos": "right", "children": [{"name": "Fare <= 3.96", "parent": 12, "self": 21, "sample": 321, "impurity": 0.199, "value": [285, 36], "predict": "Not Survived", "color": "red", "pos": "left", "children": [{"name": "Age <= 13.0", "parent": 21, "self": 29, "sample": 10, "impurity": 0.42, "value": [7, 3], "predict": "Not Survived", "color": "red", "pos": "left"}, {"name": "Age > 13.0", "parent": 21, "self": 30, "sample": 311, "impurity": 0.19, "value": [278, 33], "predict": "Not Survived", "color": "red", "pos": "right"}]}, {"name": "Fare > 3.96", "parent": 12, "self": 22, "sample": 13, "impurity": 0.426, "value": [9, 4], "predict": "Not Survived", "color": "red", "pos": "right", "children": [{"name": "Fare <= 4.154", "parent": 22, "self": 23, "sample": 6, "impurity": 0.444, "value": [2, 4], "predict": "Survived", "color": "green", "pos": "left"}, {"name": "Fare > 4.154", "parent": 22, "self": 24, "sample": 7, "impurity": 0.0, "value": [7, 0], "predict": "Not Survived", "color": "red", "pos": "right"}]}]}]}]}]};

        // calculate tree gap
        var tree_gap = (width - margin['left'] - margin['right']) * 1.0 / tree_depth;

        // node height scale based on number of samples
        var h_node = d3.scale.linear()
            .domain([parseInt(min_samples), parseInt(max_samples)])
            .clamp(true)
            .range([10, 350]);

        // generate tree layout (horizonal)
        var tree = d3.layout.tree().size([height, width])
            .separation(function (a, b) {
                var height = h_node(a.sample) + h_node(b.sample),
                    // horizontal distance between nodes = 16
                    distance = height / 2 + 16;
                return distance;
            });
        var diagonal = d3.svg.diagonal()
            .projection(function (d) {
                return [d.y, d.x];
            });

        var svg = d3.select('body').append('svg')
            .attr('width', width + margin.right + margin.left)
            .attr('height', height + margin.top + margin.bottom)
            .append('g')
            .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

        var i = 0, duration = 750;
        var rect_width = 15;
        // height scale for each tree node
        var y = d3.scale.linear();

        root.x0 = height / 2;
        root.y0 = 0;
        // update tree
        update(root);


        function update(source) {

            // compute the tree layout
            var nodes = tree.nodes(root).reverse(),
                links = tree.links(nodes);

            // normalize for fixed-depth
            nodes.forEach(function (d) {
                d.y = d.depth * tree_gap;
            });

            // draw the nodes
            var node = svg.selectAll('g.node')
                .data(nodes, function (d) {
                    return d.id || (d.id = ++i);
                });

            // enter any new nodes at the parent's previous position
            var nodeEnter = node.enter().append('g')
                .attr('class', 'node')
                .on('click', click)
                .attr('transform', function (d) {
                    return 'translate(' + source.y0 + ',' + source.x0 + ')';
                })
                .on('mouseover', mouseover)
                .on('mouseout', mouseout);

            // draw tree nodes as a stacked bar
            nodeEnter.append("g").selectAll("rect")
                .data(function (d) {
                    var y0 = 0;
                    var node_samples = d.sample;
                    y.rangeRound([h_node(node_samples), 0]).domain([0, node_samples]);
                    d.values_info = d3.keys(target_colors).map(function (i, target_name) {
                        // y0 will update 
                        return { target_name: target_name, y0: y(y0), y1: y(y0 += d.value[i]) }
                    })
                    return d.values_info;
                })
                .enter().append("rect")
                .attr("width", rect_width)
                .attr("y", function (d) { return d.y1; })
                .attr("height", function (d) { return d.y0 - d.y1; })
                .style("fill", function (d) {
                    return target_colors[d.target_name];
                });

            // add text on tree nodes
            var text_gap = 15;
            var text = nodeEnter.append('text')
                .attr('x', 18)
                .attr('y', function (d) {
                    return h_node(d.sample) / 2 - text_gap + 3;
                });

            text.append('tspan')
                .style('font-weight', 'bold')
                .text(function (d) {
                    return d.name;
                });

            text.append('tspan')
                .attr('x', 18)
                .attr('y', function (d) {
                    return h_node(d.sample) / 2 + 3;
                })
                .style('font-size', '11px')
                .style('fill', '#555')
                .text(function (d) {
                    return 'Values: [' + d.value + ']';
                });

            text.append('tspan')
                .attr('x', 18)
                .attr('y', function (d) {
                    return h_node(d.sample) / 2 + text_gap + 3;
                })
                .style('font-size', '11px')
                .style('fill', '#555')
                .text(function (d) {
                    return 'Predict: ' + d.predict;
                });

            nodeEnter.select('text').style('fill-opacity', 0);

            var nodeUpdate = node.transition()
                .duration(duration)
                .attr('transform', function (d) {
                    var height = h_node(+d.sample);
                    var width = rect_width;
                    return 'translate(' + (d.y - width / 2) + ',' + (d.x - height / 2) + ')';
                });

            nodeUpdate.select('text').style('fill-opacity', 1);

            // transition exiting nodes to the parent's new position
            var nodeExit = node.exit().transition()
                .duration(duration)
                .attr('transform', function (d) {
                    return 'translate(' + source.y + ',' + source.x + ')';
                })
                .remove();

            // hide nodes and texts
            nodeExit.select('rect').attr('height', 1e-6);
            nodeExit.select('text').style('fill-opacity', 0);

            // draw the links
            var link = svg.selectAll('path.link')
                .data(links, function (d) {
                    return d.target.id;
                });

            // enter any new links at the parent's previous position
            link.enter().insert('path', 'g')
                .attr('class', 'link')
                .attr('d', function (d) {
                    var o = { x: source.x0, y: source.y0 };
                    d_new = { source: { x: o.y, y: o.x, sample: d.source.sample }, target: { x: o.y, y: o.x, sample: d.target.sample } };
                    return sankey_link(d_new);
                })
                .style('stroke', '#eee');

            // transition links to their new position
            link.transition()
                .duration(duration)
                .attr('d', function (d) {
                    var source_h = h_node(d.source.sample);
                    var target_h = h_node(d.target.sample);
                    // center the starting points 
                    if (d.target.pos == "left") {
                        var o = { x: d.source.x - (source_h - target_h) / 2., y: d.source.y };
                    } else {
                        var o = { x: d.source.x + (source_h - target_h) / 2., y: d.source.y };
                    }
                    d_new = {
                        source: { x: o.y, y: o.x, sample: d.source.sample },
                        target: { x: d.target.y, y: d.target.x, sample: d.target.sample }
                    };
                    return sankey_link(d_new);
                });

            // transition the existing links to the parent's new position
            link.exit().transition()
                .duration(duration)
                .attr('d', function (d) {
                    var o = { x: source.x, y: source.y };
                    d_new = {
                        source: { x: o.y, y: o.x, sample: d.source.sample },
                        target: { x: o.y, y: o.x, sample: d.target.sample }
                    };
                    return sankey_link(d_new);
                }).remove();

            // stash the old positions for transition
            nodes.forEach(function (d) {
                d.x0 = d.x;
                d.y0 = d.y;
            });
        }

        function sankey_link(d_new) {
            var source_h = h_node(d_new.source.sample);
            var target_h = h_node(d_new.target.sample);

            var curvature = .5;
            var x0 = d_new.source.x,
                x1 = d_new.target.x,
                xi = d3.interpolateNumber(x0, x1),
                x2 = xi(curvature),
                x3 = xi(1 - curvature),
                y0 = d_new.source.y - target_h / 2.,
                y1 = d_new.target.y - target_h / 2.;
            return "M" + x0 + "," + y0
                + "C" + x2 + "," + y0
                + " " + x3 + "," + y1
                + " " + x1 + "," + y1
                + "L" + x1 + "," + (y1 + target_h)
                + "C" + x3 + "," + (y1 + target_h)
                + " " + x2 + "," + (y0 + target_h)
                + " " + x0 + "," + (y0 + target_h)
                + "L" + x0 + "," + y0;
        }

        // recursively color the links when hovering on a tree node
        function recurse(d, color) {
            d3.selectAll('.link').each(function (l) {
                if (l.target === d) {
                    d3.select(this).style('fill', color);
                }
            });
            if (d.parent) {
                recurse(d.parent, color);
            }
        }

        function mouseover(d) {
            // if this node has no children nodes
            if (!d.children) {
                var rule = rules[d.self];
                var append = ['Predict: ' + d.predict, 'Impurity: ' + d.impurity, ''];
                rule = append.concat(rule);

                var len = rule.length;
                var info = d3.select(this).append('g').attr('class', 'hover');
                var y0 = h_node(d.sample) + 20;
                var rules_text = info.append('g').append('text').attr('y', y0);

                for (var i = 1; i <= len; i++) {
                    rules_text.append('tspan')
                        .attr('x', 0)
                        .attr('y', y0 + i * 15)
                        .attr('text-anchor', 'left')
                        .style('font-weight', function () {
                            if (i <= 3) {
                                return 'bold';
                            } else {
                                return null;
                            }
                        })
                        .style('fill', function () {
                            if (i <= 3) {
                                return '#000';
                            } else {
                                return d.color;
                            }
                        })
                        .text(function () {
                            return rule[i - 1];
                        });
                }

                // draw the box
                var bbox = info.node().getBBox();
                var padding = 10;
                var rect = d3.select(this).insert('rect', 'g')
                    .attr('class', 'info_bg')
                    .attr('x', bbox.x - padding)
                    .attr('y', bbox.y - padding)
                    .attr('width', bbox.width + padding * 2)
                    .attr('height', bbox.height + padding * 2)
                    .style('fill', 'white')
                    .style('stroke', d.color)
                    .style('stroke-width', 2);

                // make the rule infomation on the first layer
                this.parentNode.appendChild(this);
                recurse(d, d.color);

            }
        }

        function mouseout(d) {
            d3.select('.hover').remove();
            d3.select('.info_bg').remove();

            d3.select(this).style('stroke', function (d) {
                if (d._children) {
                    var stroke_color = '#000';
                } else {
                    var stroke_color = null;
                }
                d3.select(this).selectAll('rect').style('stroke-width', 2).style('stroke', stroke_color);
                return null;
            });

            d3.selectAll('.link').style('fill', '#eee');
        }

        function click(d) {
            if (d.children) {
                d._children = d.children;
                d.children = null;
            } else {
                d.children = d._children;
                d._children = null;
            }
            update(d);
        }

    </script>
</body>

</html>